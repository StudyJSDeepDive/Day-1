<h1>⭐함수⭐</h1>

> 함수와 관련 있는 개념들 :
>
> 스코프, 실행컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화....

JS에서 함수와 수학에서의 함수는 크게 다르지 않다. 우리가 알고 있는 수학의 함수는 변수를 받아 내부에서 연산처리를 통해 결과를 출력하는데, JS의 함수도 그러하다.

<h3>1. 함수는 무엇으로 이루어져 있는가?</h3>

```js
function multifly(a, b) {
    return a * b;
}

multifly(2, 3); // 6
```

-   한 줄 한 줄을 `statement(문)` 이라고 칭한다.
-   함수는 statement로 작성된 로직을, 코드 블록 (= `{}`)으로 감싸서 하나의 실행 단위로 정의된다. (정의 방법은 아래에...)

-   **함수명** : 다른 함수들과 구분짓는 '식별자'
    -   `multifly`
-   **매개변수 (parameter)** : 함수 내부로 입력을 전달받는 변수
    -   `ex. a와 b`
-   **인수 (argument)** : 입력값
    -   `ex. 2와 3`
-   **반환값 (return value)** : 출력된 값
    -   `ex. 2와 3을 곱해서 나온 6`

<h3>2. 함수는 어떤 과정으로 실행되는가?</h3>

1. 함수를 정의한다.
2. 인수를 함수로 전달한다.
3. 함수를 호출한다.

함수는 단순하게 설명하면 위의 3단계를 통해 실행된다.

<h3>3. 함수를 사용하는 이유는?</h3>

**"함수는 재사용하기 좋으니까요!"😀⭐**

재사용하기 좋다는 것은 유지보수하기 편리하고, 개발자가 범할 실수를 줄여줄 수 있다는 뜻이다. 이는 곧 코드의 신뢰성을 높여주는 효과를 가져다 준다.

함수도 하나의 '값'인데, 함수는 정확히 말하면 객체다. 객체에는 식별자를 붙일 수 있다. 함수의 이름을 작성할 때는 '가독성 좋은', 즉 _한 번에 함수의 내용을 파악하기 좋은 식별자로 명명하는 것이 좋다_.

> 함수가 객체이고, 일반 객체와 어떻게 다른지 18장 "함수와 일급 객체"에서 자세히 살펴보자!

<h4>4. 함수는 4가지 방식으로 정의할 수 있다.</h4>

1. **함수 선언문** (=표현식이 아닌 문)
    ```js
    function sum(a, b) {
        return a + b;
    }
    ```

-   이름 생략 안됨❌
-   변수에 할당 불가능 ❌

    > ❓🤔근데 아래처럼 **할당이 가능한 이유**는 뭘까?
    >
    > ```js
    > var sum = function sum(a, b) {
    >     return a + b;
    > };
    >
    > console.log(sum(1, 2)); // 3
    > ```
    >
    > 이것이 가능한 이유는, 자바스크립트 엔진이 코드 문맥에 따라서 '함수 선언문'으로 해석할 때가 있고, '함수 리터럴 표현식'으로 해석하는 경우가 있기 때문이다.
    >
    > 위의 예시처럼, `{ }`는 중의적 표현으로, 함수 리터럴을 변수에 할당하거나 피연산자로 사용되고 있다면, 자바스크립트 엔진은 함수 리터럴 표현식으로 해석하는 경향이 있다.
    > (리터럴은 값으로 평가되고, 선언문은 값으로 평가될 수 없다.)
    > 반면, 함수 리터럴을 단독으로 사용하면 이를 함수 선언문으로 해석한다.

<br>

-   **식별자는 함수 몸체 내부에서만 유효**

    > ❓🤔그런데 **호출이 가능한 이유**는?
    >
    > 💡*자바스크립트 엔진이 암묵적으로 함수 이름과 똑같은 이름의 식별자를 생성*하고, 여기에 함수 객체를 할당하기 때문이다.
    >
    > 따라서, 함수 **함수 이름으로 호출하는 것이 아니라**, **함수 객체를 가리키는 식별자로 호출**하는 것이다.

    ```js
    // JS 엔진은 함수명과 동일한 이름의 식별자를 생성해서 할당한다.
    const sum = function sum(a, b) {
        return a + b;
    };

    console.log(sum(1, 2)); // 3
    ```

    이러한 방식은 다음으로 살펴볼 '함수 표현식'과 매우 유사하다.
    (코드는 똑같으나, 약간 다르게 동작한다.)

-   **함수 호이스팅**이 적용되어 함수 선문문 이전에 호출 가능 ⭕

    ```
    코드가 한 줄씩 실행되는 런 타임 이전에 이뤄지는 것들:
    1. 함수 객체 생성
    2. 함수 이름과 동일한 이름의 식별자 생성
    3. 식별자에 함수 객체 할당

    런타임 전에 이미 함수 객체가 생성되어 있어 호출 가능
    ```

---

1. **함수 표현식** (=표현식인 문)

    ```js
    const sum = function sum(a, b) {
        return a + b;
    };

    console.log(sum(1, 2));
    ```

-   함수를 변수에 할당할 수 있는 이유는, **함수가 일급 객체**이기 때문이다.
    > 일급 객체: 값의 성질을 갖는 객체
-   **변수 호이스팅**이 적영되어 함수 표현식 이전에 호출 불가능❌

    ```
    코드가 한 줄씩 실행되는 런 타임 이전에 이뤄지는 것들:
    1. 변수 선언
    2. 변수 값 초기화 (undefined)

    런타임 시점에 변수의 할당문 값을 평가
    ```

---

3. Function 생성자 함수 (빌트인 함수)
    ```js
    const sum = new Function("a", "b", "return a + b");
    ```
    - new 연산자와 함께 매개변수와 함수 몸체를 문자열로 전달해서 객체를 생성하고, 이를 반환하는 함수

---

4. 화살표 함수 (ES6)
   - 화살표로 더욱 간략히 선언할 수 있음
   ```js
   const sum = (a, b) => a + b;
   ```
   - 기존 함수 표현식을 완전히 대체하기 위한 것은 ❌
     - 생성자 함수 사용 불가능
     - 기존 함수와 this 바인딩이 다름
     - 프로토타입 프로퍼티가 없고, arguments 객체를 생성하지 않음
   > 생성자 함수, this, 프로토타입, arguments를 알아야 화살표 함수 이해 가능! 그래서 이거는 나중에 다룸
